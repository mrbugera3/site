<!DOCTYPE html>
<html lang="ka">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bubble Game</title>

<style>
body{
  margin:0;
  background:#111;
  overflow:hidden;
}
canvas{
  display:block;
}
#ui{
  position:fixed;
  top:10px;
  left:10px;
  color:white;
  font-size:18px;
  font-family:Arial;
}
#gameover{
  position:fixed;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  color:white;
  text-align:center;
  display:none;
}
button{
  padding:12px 25px;
  font-size:18px;
}
</style>
</head>
<body>

<div id="ui">
Score: <span id="score">0</span><br>
Level: <span id="level">1</span>
</div>

<div id="gameover">
<h1>Game Over</h1>
<button onclick="restart()">Restart</button>
</div>

<canvas id="c"></canvas>

<script>
const c = document.getElementById("c");
const ctx = c.getContext("2d");
const scoreEl = document.getElementById("score");
const levelEl = document.getElementById("level");
const gameoverEl = document.getElementById("gameover");

let w, h;
function resize(){
  w = c.width = window.innerWidth;
  h = c.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

let player, rope, bubbles, score, gameOver, level;
let targetX = 0;
let lastShot = 0;

function init(){
  player = {x:w/2, y:h-100, w:30, h:20}; // აწეული მოთამაშე
  rope = null;
  score = 0;
  level = 1;
  gameOver = false;
  scoreEl.textContent = score;
  levelEl.textContent = level;
  gameoverEl.style.display = "none";

  spawnLevel();
}

function spawnLevel(){
  bubbles = [];
  const speed = 1 + level * 0.3;
  const size = 40;

  bubbles.push({
    x:w/2,
    y:100,
    r:size,
    dx:speed,
    dy:2
  });
}

function movePlayer(x){
  targetX = x;
}

document.addEventListener("mousemove",e=>{
  movePlayer(e.clientX);
});

c.addEventListener("touchmove", e=>{
  e.preventDefault();
  movePlayer(e.touches[0].clientX);
},{passive:false});

// shoot rope
function shoot(){
  const now = Date.now();
  if(!rope && now - lastShot > 900 && !gameOver){
    rope = {x:player.x, y:player.y};
    lastShot = now;
  }
}

document.addEventListener("click",shoot);
c.addEventListener("touchstart",shoot);

function splitBubble(b){
  if(b.r > 18){
    const speed = 1 + level * 0.3;
    bubbles.push({x:b.x, y:b.y, r:b.r/2, dx:-speed, dy:-3});
    bubbles.push({x:b.x, y:b.y, r:b.r/2, dx:speed, dy:-3});
  }
}

function loop(){
  ctx.clearRect(0,0,w,h);
  if(gameOver) return;

  // smooth movement
  player.x += (targetX - player.x) * 0.2;
  player.x = Math.max(20, Math.min(w-20, player.x));

  // draw player
  ctx.fillStyle="lime";
  ctx.fillRect(player.x-15,player.y,30,20);

  // rope
  if(rope){
    rope.y -= 10;
    ctx.strokeStyle="white";
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.moveTo(rope.x,player.y);
    ctx.lineTo(rope.x,rope.y);
    ctx.stroke();

    if(rope.y < 0) rope = null;
  }

  // bubbles
  ctx.fillStyle="red";
  bubbles.forEach(b=>{
    b.x+=b.dx;
    b.y+=b.dy;
    b.dy+=0.15;

    if(b.x-b.r<0||b.x+b.r>w) b.dx*=-1;
    if(b.y+b.r>h) b.dy=-Math.abs(b.dy);

    ctx.beginPath();
    ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
    ctx.fill();

    // collision with player
    const dx=player.x-b.x;
    const dy=player.y-b.y;
    if(Math.sqrt(dx*dx+dy*dy)<b.r){
      endGame();
    }

    // rope collision
    if(rope){
      const dx2=rope.x-b.x;
      const dy2=rope.y-b.y;
      if(Math.sqrt(dx2*dx2+dy2*dy2)<b.r){
        b.dead=true;
        rope=null;
        score+=10;
        scoreEl.textContent=score;
        splitBubble(b);
      }
    }
  });

  bubbles=bubbles.filter(b=>!b.dead);

  // next level
  if(bubbles.length===0){
    level++;
    levelEl.textContent=level;
    spawnLevel();
  }

  requestAnimationFrame(loop);
}

function endGame(){
  gameOver=true;
  gameoverEl.style.display="block";
}

function restart(){
  init();
  loop();
}

init();
loop();
</script>

</body>
</html>
